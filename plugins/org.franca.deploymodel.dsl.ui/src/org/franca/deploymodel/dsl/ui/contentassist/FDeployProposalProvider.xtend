/*
 * generated by Xtext
 */
package org.franca.deploymodel.dsl.ui.contentassist

import java.io.File
import java.util.ArrayList
import java.util.Arrays
import java.util.Collection
import java.util.Iterator
import java.util.List
import java.util.Set
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.jdt.internal.core.JavaProject
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtend2.lib.StringConcatenation
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.contentassist.ReplacementTextApplier
import org.franca.core.franca.FEnumerationType
import org.franca.core.franca.FStructType
import org.franca.core.franca.FType
import org.franca.core.franca.FTypeCollection
import org.franca.core.franca.FUnionType
import org.franca.core.utils.FrancaIDLUtils
import org.franca.deploymodel.core.FDModelUtils
import org.franca.deploymodel.dsl.fDeploy.FDModel
import org.franca.deploymodel.dsl.fDeploy.FDOverwriteElement
import org.franca.deploymodel.dsl.fDeploy.FDeployPackage
import org.franca.deploymodel.dsl.fDeploy.Import
import org.franca.deploymodel.dsl.scoping.DeploySpecProvider
import org.franca.deploymodel.dsl.scoping.DeploySpecProvider.DeploySpecEntry
import com.google.common.base.Joiner
import com.google.common.collect.Lists
import com.google.common.collect.Sets
import com.google.inject.Inject

/** 
 * see
 * http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on
 * how to customize content assistant
 * 
 * TODO: convert this to real Xtend (has been converted automatically from bad Java code)
 */
class FDeployProposalProvider extends AbstractFDeployProposalProvider {
	@Inject package DeploySpecProvider deploySpecProvider
	@Inject package ContainerUtil containerUtil
	protected final static String[] extensionsForImportURIScope = (#["fidl", "fdepl"] as String[])
	static final Void static_initializer = {
		{
			Arrays::sort(extensionsForImportURIScope)
		}
		null
	}

	/** 
	 * Avoid generic proposal "importURI". 
	 */
	override void complete_STRING(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var Assignment ass = GrammarUtil::containingAssignment(ruleCall)
		if (ass === null || !"importURI".equals(ass.getFeature())) {
			super.complete_STRING(model, ruleCall, context, acceptor)
		}
	}

	override void completeFDTypes_Target(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var IScope scope = this.getScopeProvider().getScope(model, FDeployPackage::Literals::FD_TYPES__TARGET)
		for (IEObjectDescription description : scope.getAllElements()) {
			// only FTypeCollection instances will be in the scope
			var FTypeCollection collection = (description.getEObjectOrProxy() as FTypeCollection)
			var String qualifiedName = description.getQualifiedName().toString()
			var String uri = collection.eResource().getURI().toString()
			if (collection.getName() === null || collection.getName().isEmpty()) {
				acceptor.accept(
					this.createCompletionProposal(qualifiedName, '''«qualifiedName» (anonymous) - «uri»'''.toString,
						null, context))
			} else {
				acceptor.accept(
					this.createCompletionProposal(qualifiedName, '''«qualifiedName» - «uri»'''.toString, null, context))
			}
		}
	}

	/** 
	 * Proposes both all fidl and fdepl files in the current workspace (to be
	 * precise: the files residing in visible containers) as well as the
	 * fdepl-files contributed by means of
	 * <code> &lt;extension point="org.franca.deploymodel.dsl.deploySpecProvider"> </code>
	 */
	override void completeImport_ImportURI(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var List<IContainer> visibleContainers = containerUtil.getVisibleContainers(model.eResource())
		var URI fromURI = model.eResource().getURI()
		var List<URI> proposedURIs = new ArrayList<URI>()
		var FDModel fdmodel = null
		if (model instanceof FDModel) {
			fdmodel = model as FDModel
		} else if (model instanceof Import) {
			fdmodel = model.eContainer() as FDModel
		}
		var EList<Import> imports = fdmodel.getImports()
		var List<String> importedUris = Lists::newArrayList()
		for (Import import1 : imports) {
			importedUris.add(import1.getImportURI())
		}
		for (IContainer iContainer : visibleContainers) {
			var Iterable<IResourceDescription> resourceDescriptions = iContainer.getResourceDescriptions()
			for (var Iterator<IResourceDescription> iterator = resourceDescriptions.iterator(); iterator.hasNext();) {
				var IResourceDescription desc = (iterator.next() as IResourceDescription)
				var URI uri = desc.getURI()
				if (!uri.equals(fromURI) &&
					Arrays::binarySearch(extensionsForImportURIScope, uri.fileExtension()) > -1) {
					proposedURIs.add(desc.getURI())
				}
			}
		}
		for (URI uri : proposedURIs) {
			var String result = FrancaIDLUtils::relativeURIString(fromURI, uri)
			if (!importedUris.contains(result)) {
				var String displayString = '''«uri.lastSegment()» - «result»'''.toString
				acceptor.accept(createCompletionProposal('''"«result»"'''.toString, displayString, null, context))
			}
		}
		var List<URI> classpathResources = Lists::newArrayList()
		var XtextResourceSet resourceSet = (model.eResource().getResourceSet() as XtextResourceSet)
		var Object classpathURIContext = resourceSet.getClasspathURIContext()
		if (classpathURIContext instanceof JavaProject) {
			for (IContainer iContainer : visibleContainers) {
				var Iterable<IResourceDescription> resourceDescriptions = iContainer.getResourceDescriptions()
				for (IResourceDescription iResourceDescription : resourceDescriptions) {
					if (iResourceDescription.getURI().toString() !== model.eResource().getURI().toString() &&
						(Arrays::binarySearch(extensionsForImportURIScope,
							iResourceDescription.getURI().fileExtension()) > -1)) {
						classpathResources.add(iResourceDescription.getURI())
					}
				}
			}
		}
		if (context.getPrefix() === "\"classpath:") {
			createProposals(context, acceptor, classpathResources, fromURI, importedUris)
		} else {
			createProposals(context, acceptor, classpathResources, fromURI, importedUris)
		}
		super.completeImport_ImportURI(model, assignment, context, acceptor)
	}

	def private void createProposals(ContentAssistContext context, ICompletionProposalAcceptor acceptor,
		List<URI> classpathResources, URI fromURI, List<String> importedUris) {
		for (URI path : classpathResources) {
			var String result = toClassPathString(path)
			if (!importedUris.contains(result)) {
				var String displayString = '''«path.lastSegment()» - «result»'''.toString
				createProposal(result, displayString, context, acceptor)
			}
		}
	}

	override void completeImport_ImportedSpec(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var Collection<DeploySpecEntry> entries = deploySpecProvider.getEntries()
		for (var Iterator<DeploySpecEntry> iterator = entries.iterator(); iterator.hasNext();) {
			var DeploySpecEntry dse = iterator.next()
			acceptor.accept(
				createCompletionProposal(dse.alias, '''«dse.alias» - «dse.resourceId»'''.toString, null, context))
		}
	}

	def String toClassPathString(URI uri) {
		var String _xblockexpression = null
		{
			var List<String> _segmentsList = uri.segmentsList()
			val List<String> segments = this.classPathSegments(_segmentsList)
			var StringConcatenation _builder = new StringConcatenation()
			_builder.append("classpath:/")
			var Joiner _on = Joiner::on("/")
			var String _join = _on.join(segments)
			_builder.append(_join, "")
			_xblockexpression = _builder.toString()
		}
		return _xblockexpression
	}

	def List<String> classPathSegments(List<String> list) {
		var List<String> _xblockexpression = null
		{
			var int _size = list.size()
			var List<String> sublist = list.subList(3, _size)
			_xblockexpression = sublist
		}
		return _xblockexpression
	}

	def void createProposal(String name, String substring, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var StringConcatenation _builder = new StringConcatenation()
		var String _string = name.toString()
		_builder.append(_string, "")
		var ICompletionProposal proposal = this.createCompletionProposal(_builder.toString(), substring, null, context)
		if ((proposal instanceof ConfigurableCompletionProposal)) {
			var ConfigurableCompletionProposal c = ((proposal as ConfigurableCompletionProposal))
			c.setTextApplier(([ConfigurableCompletionProposal prop|
				var String _xblockexpression = null
				{
					var int _replaceContextLength = prop.getReplaceContextLength()
					prop.setReplacementLength(_replaceContextLength)
					var StringConcatenation _builder1 = new StringConcatenation()
					_builder1.append("\"")
					var String _string1 = name.toString()
					_builder1.append(_string1, "")
					_builder1.append("\"")
					_xblockexpression = _builder1.toString()
				}
				return _xblockexpression
			] as ReplacementTextApplier))
		}
		acceptor.accept(proposal)
	}

	/** 
	 * A set of keywords which will be filtered from the proposals list.
	 */
	Set<String> filteredKeywords = Sets::newHashSet()

	override void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		if(filteredKeywords.contains(keyword.getValue())) return;
		super.completeKeyword(keyword, contentAssistContext, acceptor)
	}

	override void complete_FDTypeOverwrites(EObject elem, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var FType targetType = null
		if (elem instanceof FDOverwriteElement) {
			targetType = FDModelUtils::getOverwriteTargetType((elem as FDOverwriteElement))
		}
		if (targetType === null) {
			showKeywords(false, false, false, false)
		} else {
			if (targetType instanceof FEnumerationType) {
				showKeywords(true, true, false, false)
			} else if (targetType instanceof FStructType) {
				showKeywords(true, false, true, false)
			} else if (targetType instanceof FUnionType) {
				showKeywords(true, false, false, true)
			} else {
				showKeywords(true, false, false, false)
			}
		}
	}

	def private void showKeywords(boolean plain, boolean enumeration, boolean struct, boolean union) {
		val String p = "#"
		val String e = "#enumeration"
		val String s = "#struct"
		val String u = "#union"
		if(plain) filteredKeywords.remove(p) else filteredKeywords.add(p)
		if(enumeration) filteredKeywords.remove(e) else filteredKeywords.add(e)
		if(struct) filteredKeywords.remove(s) else filteredKeywords.add(s)
		if(union) filteredKeywords.remove(u) else filteredKeywords.add(u)
	}
}
